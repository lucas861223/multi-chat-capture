var tmi = require("tmi.js");

//where you're the broadcaster
const mainChannel = "#lucas861223";
//list of channels to join
const channelList = ["lucas861223"];

const chatContainer = document.getElementById("chat");

var globalBadge = [];
var globalBTTVEmotes = [];
var channelBadge = {};
var channelBTTVEmotes = {};
var channelPFP = {};
var needsPFP = channelList.length > 1;
var needsPFPOverride = false;
var pfpOverride = false;
var mentionHighlightOvverride = false;
var userColor = {};
var messageCounter = 0;
var messageGroup = 0;
var color = getComputedStyle(document.body).getPropertyValue('--background');
var textShadow = false;

const textShadowSetting = '0.05em 0.05em 0.1em #000000'
const defaultColors = ["#FF0000", "#0000FF", "#00FF00", "#B22222", "#FF7F50", "#9ACD32",
  "#FF4500", "#2E8B57", "#DAA520", "#D2691E", "#5F9EA0", "#1E90FF", "#FF69B4", "#8A2BE2", "#00FF7F"];


prepareEmotes();
async function prepareEmotes() {
  prepareGlobalEmotes();
  for (index in channelList) {
    await fetchChannelBadgesAndEmotes(channelList[index]);
  }
}

var client = tmi.client({
  channels: channelList,
  connection: {
    reconnect: true,
  }
});

connectClient()
async function connectClient() {
  await client.connect().catch((err) => {
    throw new Error(`Failed to connect to channel ` + err);
  });
}

client.on('message', async function (channel, userstate, message, self) {
  //commands
  if (!self && message[0] === "!" && '#' + userstate["username"] === mainChannel && channel === mainChannel) {
    var parts = message.split(/ +/);
    var command = parts[0].slice(1).toLowerCase();
    if (command == "join") {
      var initialLength = client.channels.length;
      var joinChannelList = message.toLowerCase().split(/[ ,]+/);
      joinChannelList.splice(0, 1);
      for (i in joinChannelList) {
        var index = client.channels.indexOf('#' + joinChannelList[i]);
        if (index == -1) {
          await fetchChannelBadgesAndEmotes(joinChannelList[i]);
          client.join(joinChannelList[i])
          initialLength++;
        }
      }
      needsPFP = initialLength > 1;
    } else if (command == "leave") {
      var leavingChannelList = message.toLowerCase().split(/[ ,]+/);
      leavingChannelList.splice(0, 1);
      var initialLength = client.channels.length;
      for (i in leavingChannelList) {
        var index = client.channels.indexOf('#' + leavingChannelList[i]);
        if (index > -1 && '#' + leavingChannelList[i] != mainChannel) {
          delete channelPFP['#' + leavingChannelList[i]];
          delete channelBadge['#' + leavingChannelList[i]];
          delete channelBTTVEmotes['#' + leavingChannelList[i]];
          client.part(leavingChannelList[i]);
          initialLength--;
        }
      }
      needsPFP = initialLength > 1;
    } else if (command === "pfp") {
      needsPFPOverride = true;
      pfpOverride = !needsPFP;
    } else if (command === "hightlight") {
      mentionHighlightOvverride = !mentionHighlightOvverride;
    } else if (command === "clear") {
      clearChat();
    } else if (command === "shadow") {
      textShadow = !textShadow;
      document.documentElement.style.setProperty('--text-shadow', textShadow ? textShadowSetting : '');
    } else if (parts.length > 1) {
      if (command === "size") {
        document.documentElement.style.setProperty('--font-size', parts[1]);
        document.documentElement.style.setProperty('--emote-size', parseInt(parts[1]) * 1.5);
      } else if (command === "font") {
        document.documentElement.style.setProperty('--font-family', parts[1]);
      } else if (command === "color") {
        document.documentElement.style.setProperty('--color', parts[1]);
      } else if (command === "background") {
        color = parts[1] + color.substring(7, 9);
        document.documentElement.style.setProperty('--background', color);
      } else if (command === "opacity") {
        color = color.substring(0, 8) + parseInt(parts[1]).toString(16);
        document.documentElement.style.setProperty('--background', color);
      }
    }
  } else {
    messageCounter++;
    if (messageCounter > 40) {
      messageCounter = 0;
      messageGroup++;
      reduceMessages();
    }
    //normal chat
    var containerHTML = '<div class="chatMessage" messageGroup="' + messageGroup + '" id="' + userstate['id'] + '" username="' + userstate['username'] + '" channel="' + channel + '"';
    highLighted = message.toLowerCase().includes('@' + mainChannel.toLowerCase().slice(1)) && !mentionHighlightOvverride;
    if (highLighted) {
      containerHTML += ' style="background-color:#f13636"'
    }
    containerHTML += ">";
    badges = formatBadges(channel, userstate['badges']);
    if (userstate['color']) {
      username = '<b style="color:' + userstate['color'] + '">' + userstate['display-name'] + "</b>";
    } else {
      if (!(userstate['username'] in userColor)) {
        userColor[userstate['username']] = defaultColors[Math.floor(Math.random() * defaultColors.length)];
      }
      username = '<b style="color:' + userColor[userstate['username']] + '">' + userstate['display-name'] + "</b>";
    }
    formattedMessage = formatMessage(message, userstate['emotes'], channel);
    if (highLighted) {
      formattedMessage = '<b style="color:#ffffff;">' + formattedMessage + '</b>';
    } else if (userstate['message-type'] === 'action') {
      formattedMessage = '<span style="' + (userstate['color'] ? userstate['color'] : userColor[userstate['username']]) + '">' + formattedMessage + '</span>';
    }
    chatContainer.insertAdjacentHTML('beforeEnd', containerHTML + badges + username + '<b>: </b>' + formattedMessage + '</div>');
    document.body.scrollTop = document.body.scrollHeight;
  }
});

client.on('messagedeleted', function (channel, username, deletedMessage, userstate) {
  var mesesage = document.getElementById(userstate["target-msg-id"]);
  if (mesesage) {
    mesesage.remove();
  }
});

client.on('ban', function (channel, user, duration, tags) {
  clearMessageFromUser(channel, user);
});

client.on('timeout', function (channel, user, duration, tags) {
  clearMessageFromUser(channel, user);
});

function clearMessageFromUser(channel, user) {
  var messages;
  if (channel === mainChannel) {
    messages = document.querySelectorAll('[username="' + user + '"]');
  } else {
    messages = document.querySelectorAll('[username="' + user + '"][channel="' + channel + '"]');
  }
  if (messages) {
    Array.prototype.forEach.call(messages, function (node) {
      node.remove();
    });
  }
}

client.on('clearchat', function (channel, username, deletedMessage, userstate) {
  if (channel === mainChannel) {
    clearChat();
  } else {
    messages = document.querySelectorAll('[channel="' + channel + '"]');
    if (messages) {
      Array.prototype.forEach.call(messages, function (node) {
        node.remove();
      });
    }
  }
});

function clearChat() {
  chatContainer.innerHTML = '';
}

function reduceMessages() {
  var messages = document.querySelectorAll('[messageGroup="' + (messageGroup - 2) + '"]');
  if (messages) {
    Array.prototype.forEach.call(messages, function (node) {
      node.remove();
    });
  }
}

function formatMessage(message, emotes, channel) {
  var messageHTML = '';
  var matchedWords = {}
  img = '<img class="emote" src="https://static-cdn.jtvnw.net/emoticons/v1/';
  bttvImg = '<img class="emote" src="https://cdn.betterttv.net/emote/';
  var emoteRange;
  for (emote in emotes) {
    emoteRange = emotes[emote][0].split("-")
    matchedWords[message.substring(parseInt(emoteRange[0]), parseInt(emoteRange[1]) + 1)] = img + emote + '/2.0" /> ';
  }
  tokens = message.split(" ");
  inSpan = false;
  for (token in tokens) {
    if (tokens[token] in matchedWords) {
      if (inSpan) {
        inSpan = false;
        messageHTML += "</span>"
      }
      messageHTML += matchedWords[tokens[token]];
    } else if (tokens[token] in globalBTTVEmotes) {
      if (inSpan) {
        inSpan = false;
        messageHTML += "</span>"
      }
      messageHTML += bttvImg + globalBTTVEmotes[tokens[token]] + '/2x" /> ';
    } else if (tokens[token] in channelBTTVEmotes[channel]) {
      if (inSpan) {
        inSpan = false;
        messageHTML += "</span>"
      }
      messageHTML += bttvImg + channelBTTVEmotes[channel][tokens[token]] + '/2x" /> ';
    } else {
      if (!inSpan) {
        inSpan = true;
        messageHTML += "<span>"
      }
      messageHTML += tokens[token] + ' ';
    }
  }
  if (inSpan) {
    messageHTML += "</span>"
  }
  return messageHTML;
}

function formatBadges(channel, userBadges) {
  var badgesHTML = '';
  if ((!needsPFPOverride && needsPFP) || (needsPFPOverride && pfpOverride)) {
    badgesHTML += '<img class="pfp" src="' + channelPFP[channel] + '"/>'
  }
  const img = '<img class="badge" src="';
  for (var badge in userBadges) {
    if (badge in channelBadge[channel]['badge_sets'] && userBadges[badge] in channelBadge[channel]['badge_sets'][badge]['versions']) {
      badgesHTML += img + channelBadge[channel]['badge_sets'][badge]['versions'][userBadges[badge]]['image_url_2x'] + '"/>';
    } else {
      badgesHTML += img + globalBadge['badge_sets'][badge]['versions'][userBadges[badge]]['image_url_2x'] + '"/>';
    }
  }
  return badgesHTML;
}

async function fetchChannelBadgesAndEmotes(channelName) {
  if(channelName[0] === '#') {
    channelName = channelName.substring(1);
  } 
  channel = '#' + channelName;
  channelBadge[channel] = {};
  channelBTTVEmotes[channel] = {};
  var user = await fetch('https://api.twitch.tv/kraken/users?login=' + channelName, {
    headers: {
      "Client-ID": "uo32ie3c8upn1xqoy0gffc3kecypfc",
      "Accept": "application/vnd.twitchtv.v5+json"
    }
  }).then(response => response.json());
  var userID = user['users'][0]['_id'];
  channelPFP[channel] = user['users'][0]['logo'];
  channelBadge[channel] = await fetch('https://badges.twitch.tv/v1/badges/channels/' + userID + '/display?language=en').then(response => response.json());
  var tmpJson = await fetch('https://api.betterttv.net/3/cached/users/twitch/' + userID).then((res) => res.json());
  channelBTTVEmotes[channel] = {};
  if ('sharedEmotes' in tmpJson) {
    for (var emote in tmpJson['channelEmotes']) {
      channelBTTVEmotes[channel][tmpJson['channelEmotes'][emote].code] = tmpJson['channelEmotes'][emote].id;
    }
    for (var emote in tmpJson['sharedEmotes']) {
      channelBTTVEmotes[channel][tmpJson['sharedEmotes'][emote].code] = tmpJson['sharedEmotes'][emote].id;
    }
  }
}

async function prepareGlobalEmotes() {
  globalBadge = await fetch('https://badges.twitch.tv/v1/badges/global/display').then((res) => res.json());
  var tmpJson = await fetch('https://api.betterttv.net/3/cached/emotes/global').then((res) => res.json());
  for (var emote in tmpJson) {
    globalBTTVEmotes[tmpJson[emote].code] = tmpJson[emote].id;
  }
}